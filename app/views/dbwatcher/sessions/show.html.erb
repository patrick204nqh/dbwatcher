<div class="h-full flex flex-col" x-data="sessionView()">
  <%= render partial: 'session_header', locals: { session: @session } %>
  <%= render partial: 'tab_navigation' %>

  <!-- Content -->
  <div class="flex-1 overflow-auto">
    <%= render partial: 'summary_tab', locals: { tables_summary: @tables_summary } %>
    <%= render partial: 'changes_tab', locals: { tables_summary: @tables_summary } %>
    <%= render partial: 'diagrams_tab' %>
  </div>
</div>

<script>
function sessionView() {
  return {
    activeTab: '<%= @active_tab %>',
    showColumnSelector: null,
    tableColumns: {},
    selectedDiagramType: 'database_tables',
    diagramContent: null,
    diagramError: null,
    loading: false,
    diagramCache: {},

    init() {
      // Initialize column visibility for each table
      <% @tables_summary.each do |table_name, summary| %>
        this.tableColumns['<%= table_name %>'] = {};
        <% if summary[:sample_record] %>
          <% summary[:sample_record].keys.each do |column| %>
            this.tableColumns['<%= table_name %>']['<%= column %>'] = true;
          <% end %>
        <% end %>
      <% end %>

      // Set up browser navigation handling
      window.addEventListener('popstate', () => {
        const params = new URLSearchParams(window.location.search);
        const tab = params.get('tab') || 'changes';
        if (this.activeTab !== tab) {
          this.activeTab = tab;
        }
      });
    },

    setActiveTab(tab) {
      this.activeTab = tab;
      this.updateURL(tab);
    },

    updateURL(tab) {
      const url = new URL(window.location);
      url.searchParams.set('tab', tab);
      window.history.pushState({}, '', url);
    },

    scrollToTable(tableName) {
      this.setActiveTab('changes');
      setTimeout(() => {
        const element = document.getElementById(`table-${tableName}`);
        if (element) {
          element.scrollIntoView({ behavior: 'smooth' });
        }
      }, 100);
    },

    toggleColumnSelector(tableName) {
      this.showColumnSelector = this.showColumnSelector === tableName ? null : tableName;
    },

    selectAllColumns(tableName) {
      Object.keys(this.tableColumns[tableName]).forEach(column => {
        this.tableColumns[tableName][column] = true;
      });
    },

    selectNoneColumns(tableName) {
      Object.keys(this.tableColumns[tableName]).forEach(column => {
        this.tableColumns[tableName][column] = false;
      });
    },

    exportData() {
      const data = [];
      <% @tables_summary.each do |table_name, summary| %>
        <% summary[:changes].each do |change| %>
          data.push({
            table: '<%= table_name %>',
            operation: '<%= change['operation'] || change[:operation] || 'UNKNOWN' %>',
            timestamp: '<%= change['timestamp'] || change[:timestamp] %>',
            record_id: '<%= change['record_id'] || change[:record_id] %>',
            changes: '<%= change['changes'].to_json if change['changes'] %>'
          });
        <% end %>
      <% end %>

      const csv = [
        ['Table', 'Operation', 'Timestamp', 'Record ID', 'Changes'],
        ...data.map(row => [row.table, row.operation, row.timestamp, row.record_id, row.changes])
      ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `session-<%= @session.id %>-changes.csv`;
      a.click();
      URL.revokeObjectURL(url);
    },

    async loadDiagram() {
      this.loading = true;
      this.diagramContent = null;
      this.diagramError = null;

      const container = document.getElementById('diagram-container');
      if (!container) {
        this.loading = false;
        return;
      }

      // Check cache first
      const cacheKey = `<%= @session.id %>_${this.selectedDiagramType}`;
      if (this.diagramCache[cacheKey]) {
        console.log('Using cached diagram');
        this.diagramContent = this.diagramCache[cacheKey];
        this.loading = false;
        await this.renderMermaid();
        return;
      }

      try {
        const response = await fetch(`/dbwatcher/sessions/<%= @session.id %>/diagram?diagram_type=${this.selectedDiagramType}`);

        if (!response.ok) {
          throw new Error(`Server error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (data.error) {
          console.error('Diagram generation error:', data.error);
          throw new Error(data.error);
        }

        // Store the content but ensure it's valid for rendering
        if (typeof data.content !== 'string' || !data.content.trim()) {
          throw new Error('Received empty diagram content from server');
        }

        // Add some debug info as HTML comments to help with troubleshooting
        this.diagramContent = `%%{init: {'theme': 'neutral', 'themeVariables': {'fontSize': '14px'} }}%%\n${data.content}`;

        // Cache the diagram
        this.diagramCache[cacheKey] = this.diagramContent;

        console.log('Received diagram content:', this.diagramContent);

        await this.renderMermaid();
      } catch (error) {
        console.error('Failed to load diagram:', error);
        this.diagramError = error.message || 'Failed to load diagram. Please try again.';
      } finally {
        this.loading = false;
      }
    },

    async renderMermaid() {
      if (!this.diagramContent) return;

      const container = document.getElementById('diagram-container');
      if (!container) return;

      try {
        // Use MermaidHelper if available
        if (window.MermaidHelper) {
          await window.MermaidHelper.renderDiagram(
            this.diagramContent,
            container,
            this.selectedDiagramType
          );

          // Apply zoom level after rendering
          this.applyZoom();

          // Add accessibility features
          window.MermaidHelper.enhanceAccessibility(container);
        } else {
          // Fallback to original implementation
          // Determine diagram type - this affects rendering approach
          const isModelAssociationDiagram = this.selectedDiagramType === 'model_associations';
          console.log(`Attempting to render ${isModelAssociationDiagram ? 'model association' : 'database tables'} diagram`);

          // Clear the container
          container.innerHTML = '';

          // Create a wrapper with unique ID
          const wrapperId = `diagram-wrapper-${Date.now()}`;
          const wrapper = document.createElement('div');
          wrapper.id = wrapperId;
          wrapper.className = 'mermaid-wrapper';
          container.appendChild(wrapper);

          // Create a fresh mermaid element
          const diagramDiv = document.createElement('div');
          diagramDiv.className = 'mermaid';

          // Special handling for model association diagrams
          if (isModelAssociationDiagram) {
            // For model associations, ensure we're using flowchart syntax
            if (!this.diagramContent.includes('flowchart')) {
              // If not already containing flowchart, modify it
              diagramDiv.textContent = this.diagramContent.replace(/^graph LR/, 'flowchart LR');
            } else {
              diagramDiv.textContent = this.diagramContent;
            }
          } else {
            diagramDiv.textContent = this.diagramContent;
          }

          wrapper.appendChild(diagramDiv);

          // Reset Mermaid to avoid any state issues
          if (window.mermaid) {
            // Always completely reset mermaid for each render to avoid state issues
            if (typeof window.mermaid.reset === 'function') {
              window.mermaid.reset();
            }

            // Configure specific settings based on diagram type
            const settings = {
              startOnLoad: false, // We'll manually trigger
              theme: 'neutral',
              securityLevel: 'loose',
              logLevel: 'warn',
              themeVariables: {
                fontSize: '14px',
                fontFamily: 'Consolas, Monaco, Lucida Console, monospace'
              }
            };

            // Add type-specific settings
            if (isModelAssociationDiagram) {
              settings.flowchart = {
                htmlLabels: true,
                useMaxWidth: true,
                curve: 'linear', // Linear for cleaner model association lines
                nodeSpacing: 50,
                rankSpacing: 100
              };
            } else {
              settings.er = {
                useMaxWidth: true,
                layoutDirection: 'LR',
                minEntityWidth: 100,
                minEntityHeight: 75
              };
            }

            // Initialize with our settings
            window.mermaid.initialize(settings);

            try {
              // Modern API approach
              const result = await window.mermaid.run({
                querySelector: '.mermaid',
                nodes: [diagramDiv]
              });

              console.log('Diagram rendered successfully using modern API');

              // Apply zoom level after rendering
              this.applyZoom();
            } catch (modernError) {
              console.warn('Modern API rendering failed, trying alternative methods:', modernError);

              try {
                // Try another approach with ID-based rendering
                const id = `mermaid-${Date.now()}`;
                diagramDiv.id = id;

                const { svg } = await window.mermaid.render(id, diagramDiv.textContent);
                wrapper.innerHTML = svg;
                console.log('Diagram rendered successfully using ID-based rendering');

                // Apply zoom level after rendering
                this.applyZoom();
              } catch (idError) {
                console.error('ID-based rendering also failed:', idError);

                // One last attempt with direct parsing - simplest approach
                try {
                  window.mermaid.parse(diagramDiv.textContent);
                  console.log('Parsing successful, letting mermaid handle rendering');
                  // If parsing succeeds but rendering fails, we'll try the manual approach
                  wrapper.innerHTML = '<div class="mermaid">' + diagramDiv.textContent + '</div>';
                  window.mermaid.init(undefined, wrapper.querySelectorAll('.mermaid'));

                  // Apply zoom level after rendering
                  this.applyZoom();
                } catch (parseError) {
                  throw new Error(`Cannot parse diagram: ${parseError.message}`);
                }
              }
            }
          } else {
            throw new Error('Mermaid library not available');
          }
        }
      } catch (error) {
        console.error('Mermaid rendering error:', error);
        this.diagramError = error.message || 'Could not render diagram';
      }
    },

    resetView() {
      // Use native interaction system to reset view
      const container = document.getElementById('diagram-container');
      if (container && window.MermaidHelper) {
        window.MermaidHelper.resetView(container);
      }
    },

    exportDiagram() {
      if (!this.diagramContent) return;

      if (window.MermaidHelper) {
        // Use MermaidHelper for export
        const container = document.getElementById('diagram-container');
        const filename = `session-<%= @session.id %>-${this.selectedDiagramType}.svg`;
        const success = window.MermaidHelper.exportDiagram(container, filename);

        if (!success) {
          alert('Failed to export diagram. Please try again.');
        }
      } else {
        // Fallback to original implementation
        const svg = document.querySelector('#diagram-container svg');
        if (svg) {
          // Clone the SVG to avoid modifying the displayed one
          const svgClone = svg.cloneNode(true);

          // Reset any transform on the clone
          svgClone.style.transform = '';

          const svgData = new XMLSerializer().serializeToString(svgClone);
          const blob = new Blob([svgData], { type: 'image/svg+xml' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `session-<%= @session.id %>-${this.selectedDiagramType}.svg`;
          a.click();
          URL.revokeObjectURL(url);
        } else {
          alert('No diagram to export. Please generate a diagram first.');
        }
      }
    },
  }
}
</script>
