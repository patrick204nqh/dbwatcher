<div class="h-full flex flex-col" x-data="sessionView()">
  <%= render partial: 'session_header', locals: { session: @session } %>
  <%= render partial: 'tab_navigation' %>

  <!-- Content -->
  <div class="flex-1 overflow-auto">
    <%= render partial: 'summary_tab', locals: { tables_summary: @tables_summary } %>
    <%= render partial: 'changes_tab', locals: { tables_summary: @tables_summary } %>
    <%= render partial: 'diagrams_tab' %>
  </div>
</div>

<script>
function sessionView() {
  return {
    activeTab: '<%= @active_tab %>',
    showColumnSelector: null,
    tableColumns: {},
    selectedDiagramType: 'database_tables',
    diagramContent: null,
    diagramError: null,
    loading: false,
    diagramCache: {},

    init() {
      // Initialize column visibility for each table
      <% @tables_summary.each do |table_name, summary| %>
        this.tableColumns['<%= table_name %>'] = {};
        <% if summary[:sample_record] %>
          <% summary[:sample_record].keys.each do |column| %>
            this.tableColumns['<%= table_name %>']['<%= column %>'] = true;
          <% end %>
        <% end %>
      <% end %>

      // Set up browser navigation handling
      window.addEventListener('popstate', () => {
        const params = new URLSearchParams(window.location.search);
        const tab = params.get('tab') || 'changes';
        if (this.activeTab !== tab) {
          this.activeTab = tab;
        }
      });
    },

    setActiveTab(tab) {
      this.activeTab = tab;
      this.updateURL(tab);

      // Auto-generate diagram when switching to diagrams tab with improved timing
      if (tab === 'diagrams' && !this.diagramContent && !this.loading) {
        // Use nextTick and timeout to ensure DOM is ready
        this.$nextTick(() => {
          setTimeout(() => {
            if (this.activeTab === 'diagrams' && !this.diagramContent && !this.loading) {
              this.loadDiagram();
            }
          }, 100);
        });
      }
    },

    updateURL(tab) {
      const url = new URL(window.location);
      url.searchParams.set('tab', tab);
      window.history.pushState({}, '', url);
    },

    scrollToTable(tableName) {
      this.setActiveTab('changes');
      setTimeout(() => {
        const element = document.getElementById(`table-${tableName}`);
        if (element) {
          element.scrollIntoView({ behavior: 'smooth' });
        }
      }, 100);
    },

    toggleColumnSelector(tableName) {
      this.showColumnSelector = this.showColumnSelector === tableName ? null : tableName;
    },

    selectAllColumns(tableName) {
      Object.keys(this.tableColumns[tableName]).forEach(column => {
        this.tableColumns[tableName][column] = true;
      });
    },

    selectNoneColumns(tableName) {
      Object.keys(this.tableColumns[tableName]).forEach(column => {
        this.tableColumns[tableName][column] = false;
      });
    },

    async loadDiagram(refresh = false) {
      // Don't reload if already loading
      if (this.loading) return;

      this.loading = true;
      this.diagramError = null;

      // Check cache first (unless refresh is requested)
      const cacheKey = `<%= @session.id %>_${this.selectedDiagramType}`;
      if (!refresh && this.diagramCache[cacheKey]) {
        console.log('Using cached diagram');
        this.diagramContent = this.diagramCache[cacheKey];
        this.loading = false;
        await this.renderMermaid();
        return;
      }

      try {
        // Add refresh parameter to force server-side cache refresh
        const refreshParam = refresh ? '&refresh=true' : '';
        const response = await fetch(`/dbwatcher/sessions/<%= @session.id %>/diagram?diagram_type=${this.selectedDiagramType}${refreshParam}`);

        if (!response.ok) {
          throw new Error(`Server error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (data.error) {
          console.error('Diagram generation error:', data.error);
          throw new Error(data.error);
        }

        // Store the content but ensure it's valid for rendering
        if (typeof data.content !== 'string' || !data.content.trim()) {
          throw new Error('Received empty diagram content from server');
        }

        // Add some debug info as HTML comments to help with troubleshooting
        this.diagramContent = `%%{init: {'theme': 'neutral', 'themeVariables': {'fontSize': '14px'} }}%%\n${data.content}`;

        // Cache the diagram
        this.diagramCache[cacheKey] = this.diagramContent;

        await this.renderMermaid();
      } catch (error) {
        console.error('Failed to load diagram:', error);
        this.diagramError = error.message || 'Failed to load diagram. Please try again.';
      } finally {
        this.loading = false;
      }
    },

    async renderMermaid() {
      if (!this.diagramContent) return;

      // Wait for container to be available
      await this.waitForContainer();

      const container = document.getElementById('diagram-container');
      if (!container) {
        throw new Error('Diagram container not found');
      }

      try {
        // Ensure MermaidHelper is available with retry logic
        await this.ensureMermaidHelper();

        // Use MermaidHelper if available
        if (window.MermaidHelper) {
          await window.MermaidHelper.renderDiagram(
            this.diagramContent,
            container,
            this.selectedDiagramType
          );
        } else {
          throw new Error('Mermaid helper not available after initialization');
        }
      } catch (error) {
        console.error('Mermaid rendering error:', error);
        this.diagramError = error.message || 'Could not render diagram';

        // Try recovery on first load failure
        if (!refresh && error.message.includes('Mermaid')) {
          console.log('Attempting diagram recovery after Mermaid error...');
          setTimeout(() => {
            this.diagramError = null;
            this.loadDiagram(true);
          }, 1000);
        }
      }
    },

    // Wait for diagram container to be available in DOM
    async waitForContainer(maxWait = 5000) {
      const startTime = Date.now();

      while (Date.now() - startTime < maxWait) {
        const container = document.getElementById('diagram-container');
        if (container && container.offsetParent !== null) {
          return container;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      throw new Error('Diagram container not available after waiting');
    },

    // Ensure MermaidHelper is loaded and available
    async ensureMermaidHelper(maxRetries = 3) {
      for (let i = 0; i < maxRetries; i++) {
        if (window.MermaidHelper && typeof window.MermaidHelper.renderDiagram === 'function') {
          return true;
        }

        console.log(`Waiting for MermaidHelper (attempt ${i + 1}/${maxRetries})...`);
        await new Promise(resolve => setTimeout(resolve, 500 * (i + 1)));
      }

      throw new Error('MermaidHelper not available after retries');
    },

    resetView() {
      // Use native interaction system to reset view
      const container = document.getElementById('diagram-container');
      if (container && window.MermaidHelper) {
        window.MermaidHelper.resetView(container);
      }
    },
  }
}
</script>
